# STL Supplement
该目录和tiny STL不一样，不是自成体系，而是使用的标准库的头文件们，对其进行补充或重写。可以与供其他项目自由使用。

比如<type_traits>的xxx_t别名模板在C++14才提供，因此对于以C++11作为最低标准的用户（比如我）就希望C++11就能用得上，实际上，别名模板是11的特性。再来，还有conjunction，void_t等C++17才能使用的工具也是C++11就可以提供的（在tiny stl均有实现）

<iterator>也是类似，没有提供is_xxx_iterator这种判别迭代器类型的谓词，而其iterator_traits实际是SFINAE-friendly的，所以很容易实现，顺便还提供了一些别名模板便于提取value_type等类型

<forward_list>则是我比较不满的，没有提供size和指向尾结点的指针，而在很多情况下，仅仅16byte的overhead，往往是值得的，还有就是没有提供暴露节点的API便于复用节点，这些都是我重写的要点（尽管后来写的过程中发现splice_after也是复用节点，但我觉得暴露基于节点的API更好使用）。
对于header和带有值的节点是区别的，继承一个基类，header不带值，是一个小小的优化，但是重点不是这个，重点是基类不依赖于模板而链表相关算法也有一些不依赖于值，即不依赖于模板，因此可以实现算法与类模板的解耦，这有对于每个类模板的实例化，不需要针对每个算法都生成一遍（这个trick在红黑树中也有使用）